#!/bin/sh
# vpc_init with correct order: driver -> network -> download

echo "=== Nutanix CE Direct Boot with Ionic ==="

# Function to drop to shell on error
drop_to_shell() {
    local error_msg="$1"
    echo "ERROR: $error_msg"
    send_status_update "ERROR: $error_msg - Dropping to shell" "error"
    echo "Dropping to interactive shell for debugging..."
    echo "You can now connect via serial console"
    exec /bin/sh
}

# Function to get config server from kernel command line
get_config_server() {
    if [ -f "/proc/cmdline" ]; then
        for param in $(cat /proc/cmdline); do
            case $param in
                config_server=*)
                    echo "${param#config_server=}"
                    return 0
                    ;;
            esac
        done
    fi
}

# Function to get node identifier (IP address)
get_node_id() {
    # Try to get IP address of first interface
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo | head -1); do
        ip=$(ip -4 addr show $iface 2>/dev/null | grep -o "inet [0-9.]*" | cut -d' ' -f2 | head -1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    done
    # Fallback to hostname or a default
    hostname 2>/dev/null || echo "unknown-node"
}

# Function to send status updates (works with wget)
send_status_update() {
    local message="$1"
    local phase="$2"
    local config_server=$(get_config_server)
    local node_id=$(get_node_id)
    
    echo "[STATUS] $message"
    
    # Only try to send if we have network connectivity
    if command -v wget >/dev/null 2>&1 && ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
        # Create temp file with JSON payload
        local json="{\"node_id\":\"$node_id\",\"phase\":\"$phase\",\"message\":\"$message\"}"
        echo "$json" > /tmp/status.json
        
        # Send status update using wget
        wget -q -O- --post-file=/tmp/status.json \
             --header="Content-Type: application/json" \
             "${config_server}/api/installation/status" >/dev/null 2>&1 || true
        
        rm -f /tmp/status.json
    fi
}

# Essential filesystem mounts first
echo "Setting up essential filesystems..."
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sysfs /sys 2>/dev/null || true
mount -t devtmpfs devtmpfs /dev 2>/dev/null || true

# Set basic environment
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/phoenix:$PATH
export TERM=linux
export AUTOMATED_INSTALL=true

# Load ionic driver FIRST
echo "Loading ionic driver for IBM Cloud VPC..."
send_status_update "Loading ionic driver" "driver_load"

if modprobe ionic 2>/dev/null; then
    echo "Ionic driver loaded successfully"
    send_status_update "Ionic driver loaded successfully" "driver_success"
    sleep 3  # Give driver time to initialize
    
    # Show available interfaces after driver load
    echo "Network interfaces after ionic load:"
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo); do
        echo "  - $iface"
    done
else
    drop_to_shell "Failed to load ionic driver - required for IBM Cloud VPC"
fi

# Network configuration function
configure_network_direct() {
    echo "=== Direct Network Configuration ==="

    # Find the first non-loopback interface
    iface=$(ls /sys/class/net/ | grep -v lo | head -n1)
    if [ -z "$iface" ]; then
        drop_to_shell "No network interfaces found"
    fi

    echo "Configuring $iface..."
    if ! ip link set "$iface" up; then
        drop_to_shell "Failed to bring up interface $iface"
    fi
    sleep 1

    # Write a temporary udhcpc handler
    cat >/tmp/udhcpc-handler.sh <<'EOF'
#!/bin/sh
case "$1" in
    deconfig)
        ip addr flush dev $interface
        ;;
    bound|renew)
        ip addr flush dev $interface
        ip addr add $ip/$subnet dev $interface
        ip link set $interface up

        if [ -n "$router" ]; then
            echo "Setting default route via $router"
            ip route replace default via $router dev $interface
        fi

        if [ -n "$dns" ]; then
            echo -n > /etc/resolv.conf
            for ns in $dns; do
                echo "nameserver $ns" >> /etc/resolv.conf
            done
        fi
        ;;
esac
EOF
    chmod +x /tmp/udhcpc-handler.sh

    # Run udhcpc with the handler
    if udhcpc -i "$iface" -n -q -s /tmp/udhcpc-handler.sh; then
        echo "Network configuration successful on $iface"
        echo "---"
        ip a show dev "$iface"
        ip route show
        echo "DNS:"
        cat /etc/resolv.conf
        echo "---"

        # Send status update
        send_status_update "VPC init script started and IP assigned" "boot"

        return 0
    else
        drop_to_shell "Network configuration failed on $iface"
    fi

        
    # Test connectivity
    echo "Testing network connectivity..."
    if ping -c 2 -W 5 8.8.8.8 >/dev/null 2>&1; then
        echo "Internet connectivity verified"
        send_status_update "Network configured successfully with internet access" "network_success"
        return 0
    else
        echo "Warning: No internet connectivity"
        send_status_update "Network configured but no internet access" "network_partial"
        return 0  # Continue anyway - might be local network only
    fi
}

# Configure network first
configure_network

# Check for required environment variable
if [ -z "$LIVEFS_URL" ]; then
    drop_to_shell "LIVEFS_URL environment variable not set"
fi

# Now download squashfs image
echo "Downloading squashfs image from $LIVEFS_URL..."
send_status_update "Downloading squashfs image" "download_start"

if command -v wget >/dev/null 2>&1; then
    if wget -O /squashfs.img "$LIVEFS_URL"; then
        echo "Download successful using wget"
    else
        drop_to_shell "Failed to download squashfs image using wget"
    fi
else
    drop_to_shell "No HTTP client available (wget not found)"
fi

# Verify the downloaded file exists and has content
if [ ! -s /squashfs.img ]; then
    drop_to_shell "Downloaded squashfs image is empty or doesn't exist"
fi

echo "Downloaded file size: $(ls -lh /squashfs.img | awk '{print $5}')"
send_status_update "Squashfs image downloaded successfully" "download_complete"

# Mount squashfs
echo "Mounting squashfs image..."
mkdir -p /mnt/squashfs
if ! mount -t squashfs /squashfs.img /mnt/squashfs; then
    drop_to_shell "Failed to mount squashfs image"
fi

# Verify squashfs mount was successful
if [ ! -d /mnt/squashfs/usr/bin ]; then
    drop_to_shell "Squashfs mount appears unsuccessful - /mnt/squashfs/usr/bin not found"
fi

echo "Squashfs mounted successfully"
send_status_update "Squashfs mounted successfully" "mount_success"

# Add squashfs binaries to PATH
export PATH=/mnt/squashfs/usr/bin:$PATH

# Update PATH with all required directories
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/phoenix:/mnt/squashfs/usr/bin:$PATH

# Launch installation
echo "Starting automated installation..."
send_status_update "Starting automated installation" "install_start"

# Check if installation script exists
if [ ! -f "/phoenix/vpc_ce_installation.py" ]; then
    drop_to_shell "Installation script not found at /phoenix/vpc_ce_installation.py"
fi

# Verify Python is available (might be in squashfs)
if ! command -v python >/dev/null 2>&1; then
    # Try python3
    if ! command -v python3 >/dev/null 2>&1; then
        drop_to_shell "Python interpreter not found (tried python and python3)"
    else
        echo "Using python3 interpreter"
        alias python=python3
    fi
fi

# Change to the correct directory
if ! cd /phoenix; then
    drop_to_shell "Failed to change to /phoenix directory"
fi

# Execute the Python script with error handling
send_status_update "Executing Python installation script" "python_exec"
echo "Executing installation script..."

# Run the Python script and capture its exit code
if python vpc_ce_installation.py; then
    echo "Installation completed successfully"
    send_status_update "Installation completed successfully" "install_complete"
else
    drop_to_shell "Python installation script failed with exit code $?"
fi

# If we reach here, installation was successful
echo "Installation completed successfully!"
send_status_update "Installation completed - system ready" "install_complete"

# Provide shell access for any post-install tasks
echo "Dropping to shell for any final configurations..."
exec /bin/sh
#!/bin/sh
# vpc_init with correct order: driver -> network -> download

echo "=== Nutanix CE Direct Boot with Ionic ==="

# Function to drop to shell on error
drop_to_shell() {
    local error_msg="$1"
    echo "ERROR: $error_msg"
    send_status_update "ERROR: $error_msg - Dropping to shell" "error"
    echo "Dropping to interactive shell for debugging..."
    echo "You can now connect via serial console"
    exec /bin/sh
}

# Function to get config server from kernel command line
get_config_server() {
    if [ -f "/proc/cmdline" ]; then
        for param in $(cat /proc/cmdline); do
            case $param in
                config_server=*)
                    echo "${param#config_server=}"
                    return 0
                    ;;
            esac
        done
    fi
}

# Function to get management IP address
get_management_ip() {
    # Try to get IP address of first interface
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo | head -1); do
        ip=$(ip -4 addr show $iface 2>/dev/null | grep -o "inet [0-9.]*" | cut -d' ' -f2 | head -1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    done
    # Fallback to hostname or a default
    hostname 2>/dev/null || echo "unknown-node"
}

# Function to send status updates (uses curl from overlay)
send_status_update() {
    local message="$1"
    local phase="$2"
    local config_server=$(get_config_server)
    local management_ip=$(get_management_ip)
    
    echo "[STATUS] $message"
    
    # Only try to send if we have overlay with curl and network connectivity
    if [ -d /overlay ] && ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
        # Construct JSON payload
        local json="{\"management_ip\":\"$management_ip\",\"phase\":\"$phase\",\"message\":\"$message\"}"
        
        # Use curl from overlay (which has better HTTP support)
        if [ -n "$config_server" ]; then
            chroot /overlay curl -s -X POST -H "Content-Type: application/json" \
                 -d "$json" \
                 "${config_server}/api/installation/status" >/dev/null 2>&1 || true
        fi
    fi
}

# Essential filesystem mounts first
echo "Setting up essential filesystems..."
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sysfs /sys 2>/dev/null || true
mount -t devtmpfs devtmpfs /dev 2>/dev/null || true

# Set basic environment
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/phoenix:$PATH
export TERM=linux
export AUTOMATED_INSTALL=true

# Load ionic driver FIRST
echo "Loading ionic driver for IBM Cloud VPC..."
send_status_update "Loading ionic driver" "driver_load"

if modprobe ionic 2>/dev/null; then
    echo "Ionic driver loaded successfully"
    send_status_update "Ionic driver loaded successfully" "driver_success"
    sleep 3  # Give driver time to initialize
    
    # Show available interfaces after driver load
    echo "Network interfaces after ionic load:"
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo); do
        echo "  - $iface"
    done
else
    drop_to_shell "Failed to load ionic driver - required for IBM Cloud VPC"
fi

# Network configuration function
configure_network() {
    echo "=== Direct Network Configuration ==="

    # Find the first non-loopback interface
    iface=$(ls /sys/class/net/ | grep -v lo | head -n1)
    if [ -z "$iface" ]; then
        drop_to_shell "No network interfaces found"
    fi

    echo "Configuring $iface..."
    if ! ip link set "$iface" up; then
        drop_to_shell "Failed to bring up interface $iface"
    fi
    sleep 1

    # Write a temporary udhcpc handler
    cat >/tmp/udhcpc-handler.sh <<'EOF'
#!/bin/sh
case "$1" in
    deconfig)
        ip addr flush dev $interface
        ;;
    bound|renew)
        ip addr flush dev $interface
        ip addr add $ip/$subnet dev $interface
        ip link set $interface up

        if [ -n "$router" ]; then
            echo "Setting default route via $router"
            ip route replace default via $router dev $interface
        fi

        if [ -n "$dns" ]; then
            echo -n > /etc/resolv.conf
            for ns in $dns; do
                echo "nameserver $ns" >> /etc/resolv.conf
            done
        fi
        ;;
esac
EOF
    chmod +x /tmp/udhcpc-handler.sh

    # Run udhcpc with the handler
    if udhcpc -i "$iface" -n -q -s /tmp/udhcpc-handler.sh; then
        echo "Network configuration successful on $iface"
        echo "---"
        ip a show dev "$iface"
        ip route show
        echo "DNS:"
        cat /etc/resolv.conf
        echo "---"

        # Send status update
        send_status_update "VPC init script started and IP assigned" "boot"

        return 0
    else
        drop_to_shell "Network configuration failed on $iface"
    fi

        
    # Test connectivity
    echo "Testing network connectivity..."
    if ping -c 2 -W 5 8.8.8.8 >/dev/null 2>&1; then
        echo "Internet connectivity verified"
        send_status_update "Network configured successfully with internet access" "network_success"
        return 0
    else
        echo "Warning: No internet connectivity"
        send_status_update "Network configured but no internet access" "network_partial"
        return 0  # Continue anyway - might be local network only
    fi
}

# Load nvme driver
echo "Loading nvme driver for IBM Cloud VPC..."
send_status_update "Loading nvme driver" "driver_load"

if modprobe nvme 2>/dev/null; then
    echo "nvme driver loaded successfully"
    send_status_update "nvme driver loaded successfully" "driver_success"
    sleep 3  # Give driver time to initialize
    
    # Show available interfaces after driver load
    echo "Drive interfaces after nvme load:"
    for drive in $(ls ls /dev/nvme* 2>/dev/null); do
        echo "  - $drive"
    done
else
    drop_to_shell "Failed to load nvme driver - required for IBM Cloud VPC"
fi

# Function to create writable overlay from squashfs
setup_overlay() {
    echo "Creating writable overlay environment..."
    mkdir -p /overlay
    mount -t tmpfs -o size=16G tmpfs /overlay || drop_to_shell "Failed to create tmpfs overlay"

    echo "Copying squashfs to overlay (excluding virtual filesystems)..."
    for dir in /mnt/squashfs/*; do
        if [ -d "$dir" ]; then
            dirname=$(basename "$dir")
            case "$dirname" in
                proc|sys|dev)
                    echo "Skipping virtual filesystem: $dirname"
                    ;;
                *)
                    echo "Copying: $dirname"
                    cp -af "$dir" /overlay/ || drop_to_shell "Failed to copy $dirname to overlay"
                    ;;
            esac
        else
            # Copy files in root
            cp -af "$dir" /overlay/ 2>/dev/null || true
        fi
    done

    # Create mount points for virtual filesystems
    mkdir -p /overlay/proc || drop_to_shell "Failed to create /overlay/proc"
    mkdir -p /overlay/sys || drop_to_shell "Failed to create /overlay/sys"
    mkdir -p /overlay/dev || drop_to_shell "Failed to create /overlay/dev"

    # Handle phoenix directory - remove if it's a symlink
    if [ -L /overlay/phoenix ]; then
        echo "Removing phoenix symlink..."
        rm /overlay/phoenix
    fi
    mkdir -p /overlay/phoenix || drop_to_shell "Failed to create /overlay/phoenix"

    # Bind mount the real filesystems
    mount --bind /proc /overlay/proc || drop_to_shell "Failed to bind mount /proc"
    mount --bind /sys /overlay/sys || drop_to_shell "Failed to bind mount /sys"
    mount --bind /dev /overlay/dev || drop_to_shell "Failed to bind mount /dev"
    mount --bind /phoenix /overlay/phoenix || drop_to_shell "Failed to bind mount /phoenix"

    # Copy DNS configuration for name resolution
    echo "Setting up DNS in overlay..."
    cp /etc/resolv.conf /overlay/etc/resolv.conf 2>/dev/null || true
    cp /etc/hosts /overlay/etc/hosts 2>/dev/null || true

    echo "Overlay environment ready"
    send_status_update "Overlay environment created" "overlay_ready"
}

# Configure network first
configure_network

# Check for required environment variable
if [ -z "$LIVEFS_URL" ]; then
    drop_to_shell "LIVEFS_URL environment variable not set"
fi

# Now download squashfs image
echo "Downloading squashfs image from $LIVEFS_URL..."
send_status_update "Downloading squashfs image" "download_start"

if command -v wget >/dev/null 2>&1; then
    if wget -O /squashfs.img "$LIVEFS_URL"; then
        echo "Download successful using wget"
    else
        drop_to_shell "Failed to download squashfs image using wget"
    fi
else
    drop_to_shell "No HTTP client available (wget not found)"
fi

# Verify the downloaded file exists and has content
if [ ! -s /squashfs.img ]; then
    drop_to_shell "Downloaded squashfs image is empty or doesn't exist"
fi

echo "Downloaded file size: $(ls -lh /squashfs.img | awk '{print $5}')"
send_status_update "Squashfs image downloaded successfully" "download_complete"

# Mount squashfs
echo "Mounting squashfs image..."
mkdir -p /mnt/squashfs
if ! mount -t squashfs /squashfs.img /mnt/squashfs; then
    drop_to_shell "Failed to mount squashfs image"
fi

# Verify squashfs mount was successful
if [ ! -d /mnt/squashfs/usr/bin ]; then
    drop_to_shell "Squashfs mount appears unsuccessful - /mnt/squashfs/usr/bin not found"
fi

echo "Squashfs mounted successfully"
send_status_update "Squashfs mounted successfully" "mount_success"

# Update PATH with all required directories
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/phoenix:/mnt/squashfs/usr/bin:$PATH

# Set up overlay environment
setup_overlay

# Launch installation
echo "Starting automated installation..."
send_status_update "Starting automated installation" "install_start"

# Change to the correct directory
if ! cd /phoenix; then
    drop_to_shell "Failed to change to /phoenix directory"
fi

# Execute the Python script with error handling
send_status_update "Executing Python installation script" "python_exec"
echo "Executing installation script..."

# Add a 30-second wait for any key press (BusyBox compatible)
echo ""
echo "====================================================="
echo "Press any key within 30 seconds to drop to shell"
echo "Otherwise, installation will continue automatically"
echo "====================================================="
echo ""

# Wait for 30 seconds or any key press
for i in 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1; do
    echo -n "$i... "
    if read -t 1 -n 1 key; then
        echo ""
        echo "Key press detected. Dropping to shell..."
        echo "Type exit to continue with installation or use the shell for debugging."
        /bin/sh
        echo "Continuing with installation..."
        break
    fi
done

# If we completed the countdown without a key press, show 0
if [ "$i" = "1" ]; then
    echo "0"
fi
echo "Continuing with automated installation..."

# Run the Python script using chroot and capture its exit code
# chroot used to stop: /mnt/squashfs/usr/bin/python3.9  # Fails with "not found".
# The system can't find the required libraries because they're inside the squashfs
# at paths like /mnt/squashfs/lib64/, but the binary expects them at /lib64/.
if chroot /overlay /usr/bin/python3.9 /phoenix/vpc_ce_installation.py; then
    echo "Installation completed successfully"
    send_status_update "Installation completed successfully" "install_complete"
else
    drop_to_shell "Python installation script failed with exit code $?"
fi

# If we reach here, installation was successful
echo "Installation completed successfully!"
send_status_update "Installation completed - system ready" "install_complete"

# Provide shell access for any post-install tasks
echo "Dropping to shell for any final configurations..."
exec /bin/sh
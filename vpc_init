#!/bin/sh
# vpc_init - Complete driver loading and network setup with error handling

echo "=== Nutanix CE Direct Boot with Ionic ==="

# Function to drop to shell on error
drop_to_shell() {
    local error_msg="$1"
    echo "ERROR: $error_msg"
    send_status_update "ERROR: $error_msg - Dropping to shell" "error"
    echo "Dropping to interactive shell for debugging..."
    echo "You can now connect via serial console"
    exec /bin/sh
}

# Function to get config server from kernel command line
get_config_server() {
    if [ -f "/proc/cmdline" ]; then
        for param in $(cat /proc/cmdline); do
            case $param in
                config_server=*)
                    echo "${param#config_server=}"
                    return 0
                    ;;
            esac
        done
    fi
}

# Function to get node identifier (IP address)
get_node_id() {
    # Try to get IP address of first interface
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo | head -1); do
        # Use a more compatible approach without -P option
        ip=$(ip -4 addr show $iface | grep -o "inet [0-9.]*" | cut -d' ' -f2 | head -1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    done
    # Fallback to hostname or a default
    hostname 2>/dev/null || echo "unknown-node"
}

# Function to send status updates to PXE server
send_status_update() {
    local message="$1"
    local phase="$2"
    local config_server=$(get_config_server)
    local node_id=$(get_node_id)
    
    echo "[STATUS] $message"
    
    # Only try to send if we have curl
    if command -v curl >/dev/null 2>&1; then
        # Construct JSON payload
        local json="{\"node_id\":\"$node_id\",\"phase\":\"$phase\",\"message\":\"$message\"}"
        
        # Send status update to server
        curl -s -X POST -H "Content-Type: application/json" \
             -d "$json" \
             "${config_server}/api/installation/status" >/dev/null 2>&1 || true
    fi
}

# Network configuration function
configure_network_direct() {
    echo "=== Direct Network Configuration ==="

    # Find the first non-loopback interface
    iface=$(ls /sys/class/net/ | grep -v lo | head -n1)
    if [ -z "$iface" ]; then
        drop_to_shell "No network interfaces found"
    fi

    echo "Configuring $iface..."
    if ! ip link set "$iface" up; then
        drop_to_shell "Failed to bring up interface $iface"
    fi
    sleep 1

    # Write a temporary udhcpc handler
    cat >/tmp/udhcpc-handler.sh <<'EOF'
#!/bin/sh
case "$1" in
    deconfig)
        ip addr flush dev $interface
        ;;
    bound|renew)
        ip addr flush dev $interface
        ip addr add $ip/$subnet dev $interface
        ip link set $interface up

        if [ -n "$router" ]; then
            echo "Setting default route via $router"
            ip route replace default via $router dev $interface
        fi

        if [ -n "$dns" ]; then
            echo -n > /etc/resolv.conf
            for ns in $dns; do
                echo "nameserver $ns" >> /etc/resolv.conf
            done
        fi
        ;;
esac
EOF
    chmod +x /tmp/udhcpc-handler.sh

    # Run udhcpc with the handler
    if udhcpc -i "$iface" -n -q -s /tmp/udhcpc-handler.sh; then
        echo "Network configuration successful on $iface"
        echo "---"
        ip a show dev "$iface"
        ip route show
        echo "DNS:"
        cat /etc/resolv.conf
        echo "---"

        # Send status update
        send_status_update "VPC init script started and IP assigned" "boot"

        return 0
    else
        drop_to_shell "Network configuration failed on $iface"
    fi
}

# Check for required environment variable
if [ -z "$LIVEFS_URL" ]; then
    drop_to_shell "LIVEFS_URL environment variable not set"
fi

echo "Downloading squashfs image from $LIVEFS_URL..."
if ! curl -o /squashfs.img "$LIVEFS_URL"; then
    drop_to_shell "Failed to download squashfs image from $LIVEFS_URL"
fi

# Verify the downloaded file exists and has content
if [ ! -s /squashfs.img ]; then
    drop_to_shell "Downloaded squashfs image is empty or doesn't exist"
fi

# Mount squashfs
mkdir -p /mnt/squashfs
if ! mount -t squashfs /squashfs.img /mnt/squashfs; then
    drop_to_shell "Failed to mount squashfs image"
fi

# Verify squashfs mount was successful
if [ ! -d /mnt/squashfs/usr/bin ]; then
    drop_to_shell "Squashfs mount appears unsuccessful - /mnt/squashfs/usr/bin not found"
fi

# Add squashfs binaries to PATH
export PATH=/mnt/squashfs/usr/bin:$PATH

# Essential filesystem mounts
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sysfs /sys 2>/dev/null || true
mount -t devtmpfs devtmpfs /dev 2>/dev/null || true

# Set environment
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/phoenix:/mnt/squashfs/usr/bin:$PATH
export TERM=linux
export AUTOMATED_INSTALL=true

# Load ionic driver immediately
echo "Loading ionic driver for IBM Cloud VPC..."
if modprobe ionic 2>/dev/null; then
    echo "Ionic driver loaded successfully"
    sleep 3  # Give driver time to initialize
    
    # Show available interfaces
    echo "Network interfaces after ionic load:"
    ls /sys/class/net/ 2>/dev/null | grep -v lo | while read iface; do
        echo "  - $iface"
    done
else
    echo "Ionic driver not available - continuing anyway"
fi

# Configure network directly
echo "Configuring network..."
configure_network_direct

# Verify we can reach the internet (optional test)
echo "Testing network connectivity..."
if ! ping -c 1 -W 5 8.8.8.8 >/dev/null 2>&1; then
    echo "Warning: No internet connectivity detected"
    send_status_update "Warning: No internet connectivity" "network_warning"
    # Don't fail here - continue with installation attempt
fi

# Launch installation
echo "Starting automated installation..."
send_status_update "Starting automated installation" "install_start"

# Check if installation script exists
if [ ! -f "/phoenix/vpc_ce_installation.py" ]; then
    drop_to_shell "Installation script not found at /phoenix/vpc_ce_installation.py"
fi

# Verify Python is available
if ! command -v python >/dev/null 2>&1; then
    drop_to_shell "Python interpreter not found"
fi

# Change to the correct directory
if ! cd /phoenix; then
    drop_to_shell "Failed to change to /phoenix directory"
fi

# Execute the Python script with error handling
send_status_update "Executing Python installation script" "python_exec"
echo "Executing installation script..."

# Run the Python script and capture its exit code
if python vpc_ce_installation.py; then
    echo "Installation completed successfully"
    send_status_update "Installation completed successfully" "install_complete"
else
    drop_to_shell "Python installation script failed with exit code $?"
fi

# If we reach here, installation was successful but we can still provide shell access
echo "Installation completed. Dropping to shell for any post-install tasks..."
send_status_update "Installation completed - shell available" "install_complete_shell"
exec /bin/sh
#!/bin/sh
# vpc_init - Complete driver loading and network setup

echo "=== Nutanix CE Direct Boot with Ionic ==="

# Essential filesystem mounts
mount -t proc proc /proc 2>/dev/null || true
mount -t sysfs sysfs /sys 2>/dev/null || true
mount -t devtmpfs devtmpfs /dev 2>/dev/null || true

# Set environment
export PATH=/usr/sbin:/usr/bin:/sbin:/bin:/root/phoenix
export TERM=linux
export AUTOMATED_INSTALL=true

# Function to get config server from kernel command line
get_config_server() {
    if [ -f "/proc/cmdline" ]; then
        for param in $(cat /proc/cmdline); do
            case $param in
                config_server=*)
                    echo "${param#config_server=}"
                    return 0
                    ;;
            esac
        done
    fi
    # Default fallback if not found
    echo "http://pxe-server:8080"
}

# Function to get node identifier (IP address)
get_node_id() {
    # Try to get IP address of first interface
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo | head -1); do
        # Use a more compatible approach without -P option
        ip=$(ip -4 addr show $iface | grep -o "inet [0-9.]*" | cut -d' ' -f2 | head -1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    done
    # Fallback to hostname or a default
    hostname 2>/dev/null || echo "unknown-node"
}

# Function to send status updates to PXE server
send_status_update() {
    local message="$1"
    local phase="$2"
    local config_server=$(get_config_server)
    local node_id=$(get_node_id)
    
    echo "[STATUS] $message"
    
    # Only try to send if we have curl
    if command -v curl >/dev/null 2>&1; then
        # Construct JSON payload
        local json="{\"node_id\":\"$node_id\",\"phase\":\"$phase\",\"message\":\"$message\"}"
        
        # Send status update to server
        curl -s -X POST -H "Content-Type: application/json" \
             -d "$json" \
             "${config_server}/api/installation/status" >/dev/null 2>&1 || true
    fi
}

# Initial status update
send_status_update "VPC init script started" "boot"

# Network configuration function
configure_network_direct() {
    send_status_update "Starting network configuration" "network"
    echo "=== Direct Network Configuration ==="
    
    # Wait for interfaces to appear
    local count=0
    while [ $count -lt 30 ]; do
        local interfaces=$(ls /sys/class/net/ 2>/dev/null | grep -v lo)
        if [ -n "$interfaces" ]; then
            echo "Network interfaces found: $interfaces"
            break
        fi
        echo "Waiting for network interfaces... ($count/30)"
        sleep 2
        count=$((count + 1))
    done
    
    # Configure first available interface
    for iface in $(ls /sys/class/net/ 2>/dev/null | grep -v lo | head -1); do
        echo "Configuring interface: $iface"
        
        # Bring interface up
        ip link set "$iface" up
        sleep 2
        
        # Use udhcpc for DHCP (BusyBox environment)
        echo "Requesting DHCP on $iface..."
        dhcp_success=false
        
        # Use udhcpc (common in BusyBox)
        if command -v udhcpc >/dev/null 2>&1; then
            echo "Using udhcpc..."
            
            # Run udhcpc to get a lease
            if udhcpc -i "$iface" -n; then
                echo "DHCP lease obtained with udhcpc on $iface"
                
                # Get the lease information
                lease_ip=$(grep "^lease=" /var/lib/misc/udhcpc.leases 2>/dev/null | tail -1 | cut -d= -f2 | cut -d' ' -f1)
                lease_subnet=$(grep "^subnet=" /var/lib/misc/udhcpc.leases 2>/dev/null | tail -1 | cut -d= -f2)
                lease_router=$(grep "^router=" /var/lib/misc/udhcpc.leases 2>/dev/null | tail -1 | cut -d= -f2)
                lease_dns=$(grep "^dns=" /var/lib/misc/udhcpc.leases 2>/dev/null | tail -1 | cut -d= -f2)
                
                # Only proceed if we have valid lease information
                if [ -n "$lease_ip" ] && [ -n "$lease_router" ]; then
                    echo "Lease information: IP=$lease_ip, Subnet=$lease_subnet, Router=$lease_router, DNS=$lease_dns"
                    
                    # Manually apply the lease
                    echo "Manually applying DHCP lease..."
                    ip addr add "$lease_ip/$lease_subnet" dev "$iface" 2>/dev/null || ip addr add "$lease_ip/24" dev "$iface"
                    ip route del default 2>/dev/null || true
                    ip route add default via "$lease_router" dev "$iface" 2>/dev/null || true
                    
                    if [ -n "$lease_dns" ]; then
                        echo "nameserver $lease_dns" > /etc/resolv.conf
                    fi
                else
                    echo "Incomplete lease information, cannot apply manually"
                fi
                
                # Verify IP address was assigned
                if ip addr show dev "$iface" | grep -q "inet "; then
                    echo "IPv4 address successfully assigned to $iface"
                    dhcp_success=true
                else
                    echo "Failed to manually assign IPv4 address"
                    
                    # Try running udhcpc with -f (foreground) and -S (background after lease)
                    echo "Trying udhcpc with different options..."
                    udhcpc -i "$iface" -f -S
                    
                    if ip addr show dev "$iface" | grep -q "inet "; then
                        echo "IPv4 address successfully assigned to $iface with udhcpc -f -S"
                        dhcp_success=true
                    else
                        echo "All attempts to assign IPv4 address failed"
                        
                        # Continue anyway - we might have connectivity through other means
                        # or the installation might be able to proceed without full network
                        echo "Continuing without confirmed IPv4 connectivity"
                        dhcp_success=true
                    fi
                fi
            else
                echo "udhcpc failed to obtain a lease on $iface"
            fi
        fi
        
        # If DHCP failed, we'll continue anyway
        if [ "$dhcp_success" != "true" ]; then
            echo "DHCP failed, but continuing without network configuration"
            # We might have connectivity through other means
            # or the installation might be able to proceed without full network
            dhcp_success=true
        fi
        
        # Test connectivity
        if [ "$dhcp_success" = "true" ]; then
            # Wait a moment for network to stabilize
            sleep 3
            
            # Try to ping the default gateway if we have one
            if [ -n "$(ip route | grep default)" ]; then
                gateway=$(ip route | grep default | awk '{print $3}')
                if ping -c 3 -W 5 "$gateway" >/dev/null 2>&1; then
                    echo "Network connectivity to gateway verified"
                    export CONFIGURED_INTERFACE="$iface"
                    send_status_update "Network configured successfully on $iface" "network_success"
                    return 0
                else
                    echo "Cannot ping gateway, but network interface is configured"
                fi
            else
                echo "No default gateway found, but network interface is configured"
            fi
            
            # Continue anyway since we have an interface configured
                echo "Network connectivity verified"
                export CONFIGURED_INTERFACE="$iface"
                send_status_update "Network configured successfully on $iface" "network_success"
                return 0
            else
                echo "Network configured but no internet connectivity"
                # Continue anyway since we might have local network access
                export CONFIGURED_INTERFACE="$iface"
                send_status_update "Network configured but no internet" "network_partial"
                return 0
            fi
        else
            echo "All network configuration methods failed on $iface"
        fi
    done
    
    echo "Network configuration failed"
    send_status_update "Network configuration failed" "network_failed"
    return 1
}

# Load ionic driver immediately
echo "Loading ionic driver for IBM Cloud VPC..."
send_status_update "Loading ionic driver" "driver_load"
if modprobe ionic 2>/dev/null; then
    echo "Ionic driver loaded successfully"
    send_status_update "Ionic driver loaded successfully" "driver_success"
    sleep 3  # Give driver time to initialize
    
    # Show available interfaces
    echo "Network interfaces after ionic load:"
    ls /sys/class/net/ 2>/dev/null | grep -v lo | while read iface; do
        echo "  - $iface"
    done
else
    echo "Ionic driver not available"
    send_status_update "Ionic driver not available" "driver_failed"
fi

# Configure network directly
echo "Configuring network..."
configure_network_direct

# Check and install Python if needed
install_python() {
    echo "Checking for Python..."
    
    # Check for python in various locations and with different names
    for python_cmd in python python3 python2 /usr/bin/python /usr/bin/python3 /usr/bin/python2 /bin/python /bin/python3 /bin/python2; do
        if command -v $python_cmd >/dev/null 2>&1; then
            echo "Python found at: $python_cmd"
            # Create a symlink to the found Python executable
            ln -sf $(which $python_cmd) /bin/python 2>/dev/null || true
            return 0
        fi
    done
    
    echo "Python not found in standard locations, checking for embedded Python..."
    
    # Check for Python in non-standard locations
    for path in /phoenix /root/phoenix /opt/python /usr/local; do
        if [ -f "$path/python" ] && [ -x "$path/python" ]; then
            echo "Found Python at $path/python"
            ln -sf "$path/python" /bin/python 2>/dev/null || true
            return 0
        fi
    done
    
    echo "Python not found, attempting to install..."
    
    # Try to detect package manager
    if command -v apt-get >/dev/null 2>&1; then
        echo "Detected apt package manager"
        apt-get update
        apt-get install -y python3 || apt-get install -y python
    elif command -v yum >/dev/null 2>&1; then
        echo "Detected yum package manager"
        yum install -y python3 || yum install -y python
    elif command -v dnf >/dev/null 2>&1; then
        echo "Detected dnf package manager"
        dnf install -y python3 || dnf install -y python
    elif command -v apk >/dev/null 2>&1; then
        echo "Detected apk package manager"
        apk add python3 || apk add python
    else
        echo "No supported package manager found"
        
        # Check if we can extract Python from the squashfs image
        if [ -f "/squashfs.img" ]; then
            echo "Attempting to extract Python from squashfs.img..."
            mkdir -p /mnt/squashfs
            if mount -t squashfs /squashfs.img /mnt/squashfs 2>/dev/null; then
                # Look for Python in the squashfs image
                for python_path in /mnt/squashfs/usr/bin/python*; do
                    if [ -f "$python_path" ] && [ -x "$python_path" ]; then
                        echo "Found Python in squashfs: $python_path"
                        cp "$python_path" /bin/python
                        chmod +x /bin/python
                        umount /mnt/squashfs
                        return 0
                    fi
                done
                umount /mnt/squashfs
            fi
        fi
        
        return 1
    fi
    
    # Check if installation was successful
    for python_cmd in python python3 python2; do
        if command -v $python_cmd >/dev/null 2>&1; then
            echo "Python installed successfully as $python_cmd"
            ln -sf $(which $python_cmd) /bin/python 2>/dev/null || true
            return 0
        fi
    done
    
    echo "Failed to install Python"
    return 1
}

# Launch installation
echo "Starting automated installation..."
send_status_update "Starting automated installation" "install_start"
if [ -f "/phoenix/vpc_ce_installation.py" ]; then
    cd /phoenix
    
    # Try to install Python if not available
    if ! command -v python >/dev/null 2>&1; then
        echo "Python not found, attempting to install..."
        send_status_update "Python not found, attempting to install" "python_install"
        if install_python; then
            echo "Python installed, proceeding with installation"
            send_status_update "Python installed successfully" "python_success"
        else
            echo "Could not install Python, checking if we can continue without it..."
            send_status_update "Failed to install Python, checking alternatives" "python_failed"
            
            # Check if we can use a shell script instead
            if [ -f "/phoenix/vpc_ce_installation.sh" ]; then
                echo "Found shell script alternative, executing..."
                send_status_update "Using shell script alternative" "shell_script"
                chmod +x /phoenix/vpc_ce_installation.sh
                exec /phoenix/vpc_ce_installation.sh
            else
                echo "No alternative installation method found, dropping to shell"
                send_status_update "No alternative installation method found" "no_alternatives"
                exec /bin/sh
            fi
        fi
    fi
    
    # Execute the Python script
    send_status_update "Executing Python installation script" "python_exec"
    exec python vpc_ce_installation.py
else
    echo "Installation script not found at /phoenix/vpc_ce_installation.py"
    
    # Check alternative locations
    for alt_path in /root/phoenix/vpc_ce_installation.py ./phoenix/vpc_ce_installation.py; do
        if [ -f "$alt_path" ]; then
            echo "Found installation script at $alt_path"
            send_status_update "Found installation script at alternate location" "script_found"
            cd $(dirname "$alt_path")
            
            # Try to install Python if not available
            if ! command -v python >/dev/null 2>&1; then
                echo "Python not found, attempting to install..."
                send_status_update "Python not found, attempting to install" "python_install"
                if install_python; then
                    echo "Python installed, proceeding with installation"
                    send_status_update "Python installed successfully" "python_success"
                else
                    echo "Could not install Python, checking if we can continue without it..."
                    send_status_update "Failed to install Python, checking alternatives" "python_failed"
                    
                    # Check if we can use a shell script instead
                    if [ -f "vpc_ce_installation.sh" ]; then
                        echo "Found shell script alternative, executing..."
                        send_status_update "Using shell script alternative" "shell_script"
                        chmod +x vpc_ce_installation.sh
                        exec ./vpc_ce_installation.sh
                    else
                        echo "No alternative installation method found, dropping to shell"
                        send_status_update "No alternative installation method found" "no_alternatives"
                        exec /bin/sh
                    fi
                fi
            fi
            
            # Execute the Python script
            send_status_update "Executing Python installation script" "python_exec"
            exec python vpc_ce_installation.py
        fi
    done
    
    echo "Installation script not found in any location"
    send_status_update "Installation script not found in any location" "script_not_found"
    
    # List directories to help diagnose the issue
    echo "Listing root directory:"
    ls -la / 2>/dev/null || echo "Failed to list root directory"
    
    echo "Listing current directory:"
    ls -la . 2>/dev/null || echo "Failed to list current directory"
    
    echo "Checking for phoenix directory:"
    find / -name phoenix -type d 2>/dev/null || echo "No phoenix directory found"
    
    echo "Checking for vpc_ce_installation.py:"
    find / -name vpc_ce_installation.py 2>/dev/null || echo "No vpc_ce_installation.py found"
    
    exec /bin/sh
fi